<!DOCTYPE html>
<html>
<head>
    <title>Special Functions Plotter</title>
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.js" integrity="sha512-GprJ6dvjbQktLGmfh0OXM7+DuT2L0kfGyPlQ6kFk7S/K5puflrOlFvMuLGnH3ex1Cus1JkR66jDZu/6/10OvEA==" crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    <!-- Removed KaTeX CSS and JS -->
    <!-- Added MathJax Configuration and Library -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['\\(', '\\)']], // Use \( ... \) for inline math
            displayMath: [['\\[', '\\]']], // Use \[ ... \] for display math (though we use inline here)
            processEscapes: true
          },
          svg: {
            fontCache: 'global'
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            ignoreHtmlClass: 'tex2jax_ignore',
            processHtmlClass: 'tex2jax_process'
          }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>

    <style>
        /* CSS styles remain the same */
        body { font-family: sans-serif; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        #controls { margin-bottom: 20px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 15px; }
        #plotContainer { width: 90%; max-width: 800px; min-height: 400px; margin-bottom: 20px; border: 1px solid #eee; position: relative; }
        #plotMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-style: italic; text-align: center;}
        #infoContainer { width: 90%; max-width: 800px; padding: 15px; border: 1px solid #ccc; background-color: #f8f8f8; margin-top: 20px; min-height: 80px; }
        #equationDisplay { margin-bottom: 10px; font-size: 1.1em; }
        #physicsUsesDisplay { font-size: 0.9em; color: #333; }
        #physicsUsesDisplay strong { color: #005;}
        label { margin-right: 5px; }
        select, input[type="range"] { padding: 5px; }
        /* Removed katex-display style */
    </style>
</head>
<body>

<h1>Special Functions Plotter</h1>

<div id="controls">
    <div>
        <label for="functionSelect">Select Function:</label>
        <select id="functionSelect">
            <optgroup label="Orthogonal Polynomials">
                <option value="legendre">Legendre P_n(x)</option>
                <option value="assoclegendre">Assoc. Legendre P_n^m(x)</option>
                <option value="hermite">Hermite H_n(x)</option>
                <option value="laguerre">Laguerre L_n(x)</option>
                <option value="chebyshev">Chebyshev T_n(x)</option>
            </optgroup>
             <optgroup label="Bessel Functions">
                <option value="besselj">Bessel J_n(x)</option>
                <option value="bessely">Bessel Y_n(x)</option>
                <option value="besseli">Modified Bessel I_n(x)</option>
                <option value="besselk">Modified Bessel K_n(x)</option>
             </optgroup>
             <optgroup label="Spherical Functions">
                 <option value="spherharm">Spherical Harmonics Y_l^m(θ, φ)</option>
                 <option value="spherbesselj">Spherical Bessel j_l(x)</option>
                 <option value="spherbessely">Spherical Bessel y_l(x)</option>
             </optgroup>
             <optgroup label="Gamma & Related">
                <option value="gamma">Gamma Γ(x)</option>
                <option value="beta">Beta B(x, n)</option>
                <option value="digamma">Digamma ψ(x)</option>
             </optgroup>
             <optgroup label="Hypergeometric & Elliptic">
                 <option value="hypergeom">Hypergeometric _2F_1(a,b;c;z)</option>
                 <option value="confhypergeom">Confluent Hypergeom. _1F_1(a;b;z)</option>
                 <option value="ellipticint">Elliptic Integrals</option>
                 <option value="ellipticfunc">Jacobi Elliptic Funcs</option>
             </optgroup>
             <optgroup label="Other Special Cases">
                 <option value="airy">Airy Ai(x), Bi(x)</option>
                 <option value="erf">Error Function erf(x)</option>
                 <option value="heaviside">Heaviside H(x)</option>
                 <option value="dirac">Dirac Delta δ(x)</option>
             </optgroup>
        </select>
    </div>
    <div>
        <label for="paramSlider" id="paramLabel">n:</label>
        <input type="range" id="paramSlider" name="paramSlider" min="0" max="5" value="2" step="1">
        <span id="paramValue">n = 2</span>
        <label for="paramSlider2" id="paramLabel2" style="display:none; margin-left: 10px;">m:</label>
        <input type="range" id="paramSlider2" name="paramSlider2" min="0" max="0" value="0" step="1" style="display:none;">
        <span id="paramValue2" style="display:none;">m = 0</span>
    </div>
</div>

<div id="plotContainer">
    <div id="plot"></div>
    <div id="plotMessage" style="display: none;">Plotting for this function is not implemented in this example.</div>
</div>

<div id="infoContainer">
    <div id="equationDisplay">Equation definition appears here.</div>
    <div id="physicsUsesDisplay">Physics uses appear here.</div>
</div>

<script>
    // --- Safe Wrapper ---
    function safeMathJs(func, ...args) {
        if (typeof math !== 'undefined' && typeof func === 'function') {
            try {
                const result = func(...args);
                return typeof result === 'number' && isFinite(result) ? result : NaN;
            } catch (e) {
                console.error(`Error in math function ${func.name}(${args.join(', ')}):`, e);
                return NaN;
            }
        } else {
            console.error(`Math.js or function ${func?.name} not available.`);
            return NaN;
        }
    }

    // --- Classical Orthogonal Polynomials ---
    function legendreP(n, x) {
        n = Math.round(n);
        if (n < 0 || x < -1 || x > 1) return NaN;
        if (n === 0) return 1;
        if (n === 1) return x;
        let p_n_minus_2 = 1, p_n_minus_1 = x, p_n = x;
        for (let i = 1; i < n; i++) {
            p_n = ((2*i + 1)*x*p_n_minus_1 - i*p_n_minus_2)/(i + 1);
            p_n_minus_2 = p_n_minus_1;
            p_n_minus_1 = p_n;
        }
        return p_n;
    }

    function hermiteH(n, x) {
        n = Math.round(n);
        if (n < 0) return NaN;
        if (n === 0) return 1;
        if (n === 1) return 2 * x;
        let h_n_minus_2 = 1, h_n_minus_1 = 2 * x, h_n = h_n_minus_1;
        for (let i = 1; i < n; i++) {
            h_n = 2 * x * h_n_minus_1 - 2 * i * h_n_minus_2;
            h_n_minus_2 = h_n_minus_1;
            h_n_minus_1 = h_n;
        }
        return h_n;
    }

    function laguerreL(n, x) {
        n = Math.round(n);
        if (n < 0) return NaN;
        if (n === 0) return 1;
        if (n === 1) return 1 - x;
        let l_n_minus_2 = 1, l_n_minus_1 = 1 - x, l_n = l_n_minus_1;
        for (let i = 1; i < n; i++) {
            l_n = ((2*i + 1 - x) * l_n_minus_1 - i * l_n_minus_2) / (i + 1);
            l_n_minus_2 = l_n_minus_1;
            l_n_minus_1 = l_n;
        }
        return l_n;
    }

    function chebyshevT(n, x) {
        n = Math.round(n);
        if (n < 0 || x < -1 || x > 1) return NaN;
        try {
            return Math.cos(n * Math.acos(x));
        } catch (e) {
            return NaN;
        }
    }

    // --- Bessel and Related Functions ---
    function besselJ(n, x) {
        n = Math.round(n);
        return safeMathJs(math.besselJ, x, n);
    }

    function besselY(n, x) {
        n = Math.round(n);
        if (x <= 0) return NaN;
        return safeMathJs(math.besselY, x, n);
    }

    function besselI(n, x) {
        n = Math.round(n);
        return safeMathJs(math.besselI, x, n);
    }

    function besselK(n, x) {
        n = Math.round(n);
        if (x <= 0) return NaN;
        return safeMathJs(math.besselK, x, n);
    }

    function spherBesselJ(l, x) {
        l = Math.round(l);
        if (x <= 0) return l === 0 ? 1 : 0;
        const order = l + 0.5;
        const besselVal = safeMathJs(math.besselJ, x, order);
        return isNaN(besselVal) ? NaN : Math.sqrt(Math.PI / (2 * x)) * besselVal;
    }

    function spherBesselY(l, x) {
        l = Math.round(l);
        if (x <= 0) return NaN;
        const order = l + 0.5;
        const besselVal = safeMathJs(math.besselY, x, order);
        return isNaN(besselVal) ? NaN : Math.sqrt(Math.PI / (2 * x)) * besselVal;
    }

    // --- Gamma and Beta Functions ---
    function gammaFunc(n_dummy, x) {
        if (x <= 0 && Math.abs(x - Math.round(x)) < 1e-9) return NaN;
        return safeMathJs(math.gamma, x);
    }

    function betaFunc(n, x) {
        if (n <= 0 || x <= 0) return NaN;
        return safeMathJs(math.beta, x, n);
    }

    // --- Special ---
    function erfFunc(n_dummy, x) {
        return safeMathJs(math.erf, x);
    }

    function heaviside(n_dummy, x) {
        return x < 0 ? 0 : 1;
    }

    function diracDelta(n_dummy, x){
        const sigma = 1e-2;
        return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-x * x / (2 * sigma * sigma));
    }

    // --- Airy Functions ---
    function airyAi(n_dummy, x) {
        return safeMathJs(math.airyAi, x);
    }

    function airyBi(n_dummy, x) {
        return safeMathJs(math.airyBi, x);
    }

    // --- Associated Legendre (m = 0 for now) ---
    function assocLegendreP(l, m, x) {
        if (m !== 0) return NaN; // Simplified version
        return legendreP(l, x);
    }
</script>



<script>
    // --- Math Function Definitions ---
    // (These remain exactly the same as the previous version)
    function safeMathJs(func, ...args) { if (typeof math !== 'undefined' && typeof func === 'function') { try { const result = func(...args); return typeof result === 'number' && isFinite(result) ? result : NaN; } catch (e) { console.error(`Error in math function ${func.name}(${args.join(', ')}):`, e); return NaN; } } else { console.error(`Math.js or function ${func?.name} not available.`); return NaN; } }
    function legendreP(n, x) { n = Math.round(n); if (n < 0) return NaN; if (x < -1 || x > 1) return NaN; if (n === 0) return 1; if (n === 1) return x; let p_n_minus_2 = 1; let p_n_minus_1 = x; let p_n = x; for (let i = 1; i < n; i++) { p_n = ((2*i + 1) * x * p_n_minus_1 - i * p_n_minus_2) / (i + 1); p_n_minus_2 = p_n_minus_1; p_n_minus_1 = p_n; } return p_n; }
    function hermiteH(n, x) { n = Math.round(n); if (n < 0) return NaN; if (n === 0) return 1; if (n === 1) return 2 * x; let h_n_minus_2 = 1; let h_n_minus_1 = 2 * x; let h_n = h_n_minus_1; for (let i = 1; i < n; i++) { h_n = 2 * x * h_n_minus_1 - 2 * i * h_n_minus_2; h_n_minus_2 = h_n_minus_1; h_n_minus_1 = h_n; } return h_n; }
    function laguerreL(n, x) { n = Math.round(n); if (n < 0) return NaN; if (n === 0) return 1; if (n === 1) return -x + 1; let l_n_minus_2 = 1; let l_n_minus_1 = -x + 1; let l_n = l_n_minus_1; for (let i = 1; i < n; i++) { l_n = ((2*i + 1 - x) * l_n_minus_1 - i * l_n_minus_2) / (i + 1); l_n_minus_2 = l_n_minus_1; l_n_minus_1 = l_n; } return l_n; }
    function chebyshevT(n, x) { n = Math.round(n); if (n < 0) return NaN; if (x < -1 || x > 1) return NaN; try { return Math.cos(n * Math.acos(x)); } catch(e) { return NaN; } }
    function besselJ(n, x) { n = Math.round(n); return safeMathJs(math.besselJ, x, n); }
    function besselY(n, x) { n = Math.round(n); if (x <= 0) return NaN; return safeMathJs(math.besselY, x, n); }
    function besselI(n, x) { n = Math.round(n); return safeMathJs(math.besselI, x, n); }
    function besselK(n, x) { n = Math.round(n); if (x <= 0) return NaN; return safeMathJs(math.besselK, x, n); }
    function spherBesselJ(l, x) { l = Math.round(l); if (x === 0) { return l === 0 ? 1 : 0; } if (x < 0) return NaN; const order = l + 0.5; if (Math.abs(x) < 1e-15) return l === 0 ? 1 : 0; const besselVal = safeMathJs(math.besselJ, x, order); if (isNaN(besselVal)) return NaN; return Math.sqrt(Math.PI / (2 * x)) * besselVal; }
    function spherBesselY(l, x) { l = Math.round(l); if (x <= 0) return NaN; const order = l + 0.5; if (Math.abs(x) < 1e-15) return NaN; const besselVal = safeMathJs(math.besselY, x, order); if (isNaN(besselVal)) return NaN; return Math.sqrt(Math.PI / (2 * x)) * besselVal; }
    function gammaFunc(n_dummy, x) { if (x <= 0 && Math.abs(x - Math.round(x)) < 1e-9) return NaN; return safeMathJs(math.gamma, x); }
    function betaFunc(n, x) { n = Math.round(n); if (n <= 0) return NaN; if (x <= 0) return NaN; const n_param = n > 0 ? n : 1; return safeMathJs(math.beta, x, n_param); }
    function erfFunc(n_dummy, x) { return safeMathJs(math.erf, x); }
    function heaviside(n_dummy, x) { return x < 0 ? 0 : 1; }
    function diracDelta(n_dummy, x){ return Math.abs(x) < 1e-3 ? Infinity : 0; }

    // --- Function Configuration Map ---
    // (Remains exactly the same as the previous version)
    const functionMap = { 'legendre': { plot: true, func: legendreP, name: "Legendre Polynomial", param1: 'n', param2: null, eq: `P_n(x)`, xRange: [-1, 1], yRange: [-1.5, 1.5], p1Max: 10, physicsUses: "Electrostatics (spherical coords, multipole expansions); Quantum mechanics (angular momentum, scattering theory); Gravitational fields." }, 'assoclegendre': { plot: false, func: null, name: "Associated Legendre Polynomial", param1: 'n', param2: 'm', eq: `P_n^m(x) = (-1)^m (1-x^2)^{m/2} \\frac{d^m}{dx^m} P_n(x)`, xRange: [-1, 1], yRange: [-1, 1], p1Max: 5, p2MaxFunc: (n) => n, physicsUses: "Component of Spherical Harmonics; Quantum mechanics (angular wavefunctions e.g., Hydrogen atom); Geophysics (Earth's gravitational/magnetic fields)." }, 'hermite': { plot: true, func: hermiteH, name: "Hermite Polynomial", param1: 'n', param2: null, eq: `H_n(x)`, xRange: [-3, 3], yRange: [-50, 50], p1Max: 8, physicsUses: "Quantum harmonic oscillator wavefunctions; Quantum field theory (path integrals); Probability (Gaussian distributions)." }, 'laguerre': { plot: true, func: laguerreL, name: "Laguerre Polynomial", param1: 'n', param2: null, eq: `L_n(x)`, xRange: [0, 10], yRange: [-10, 10], p1Max: 8, physicsUses: "Hydrogen atom radial solutions; Quantum Morse potential solutions; Quantum optics (Laguerre-Gaussian beams)." }, 'chebyshev': { plot: true, func: chebyshevT, name: "Chebyshev Polynomial (1st Kind)", param1: 'n', param2: null, eq: `T_n(x) = \\cos(n \\arccos x)`, xRange: [-1, 1], yRange: [-1.5, 1.5], p1Max: 10, physicsUses: "Numerical analysis (approximation, interpolation, quadrature); Filter design; Antenna theory." }, 'besselj': { plot: true, func: besselJ, name: "Bessel Function (1st Kind)", param1: 'n', param2: null, eq: `J_n(x)`, xRange: [0, 20], yRange: [-0.5, 1.1], p1Max: 5, physicsUses: "Vibrating circular membranes; EM waves in cylindrical waveguides; Heat conduction in cylinders; Diffraction (circular aperture)." }, 'bessely': { plot: true, func: besselY, name: "Bessel Function (2nd Kind)", param1: 'n', param2: null, eq: `Y_n(x)`, xRange: [0.1, 20], yRange: [-2, 1], p1Max: 5, physicsUses: "Solutions in cylindrical coordinates (origin excluded); EM waves/heat flow *outside* a cylinder; Acoustics." }, 'besseli': { plot: true, func: besselI, name: "Modified Bessel (1st Kind)", param1: 'n', param2: null, eq: `I_n(x)`, xRange: [-5, 5], yRange: [0, 20], p1Max: 5, physicsUses: "Heat conduction/diffusion (cylindrical, exponential-like); Laplace equation solutions (cylindrical); Probability (Bessel process)." }, 'besselk': { plot: true, func: besselK, name: "Modified Bessel (2nd Kind)", param1: 'n', param2: null, eq: `K_n(x)`, xRange: [0.1, 5], yRange: [0, 10], p1Max: 5, physicsUses: "Laplace equation solutions decaying at infinity (cylindrical); Quantum tunneling (cylindrical barrier); Hydrodynamics." }, 'spherharm': { plot: false, func: null, name: "Spherical Harmonics", param1: 'l', param2: 'm', eq: `Y_l^m(\\theta, \\phi) = \\sqrt{\\frac{(2l+1)}{4\\pi}\\frac{(l-m)!}{(l+m)!}} P_l^m(\\cos\\theta) e^{im\\phi}`, xRange: [0, Math.PI], yRange: [0, 2*Math.PI], p1Max: 4, p2MaxFunc: (l) => l, physicsUses: "Quantum angular momentum eigenstates; Atomic orbitals (angular part); Multipole expansions (EM, gravity); CMB analysis; Computer graphics." }, 'spherbesselj': { plot: true, func: spherBesselJ, name: "Spherical Bessel (1st Kind)", param1: 'l', param2: null, eq: `j_l(x) = \\sqrt{\\frac{\\pi}{2x}} J_{l+1/2}(x)`, xRange: [0, 20], yRange: [-0.3, 1.0], p1Max: 5, physicsUses: "Radial solutions in spherical coordinates (scattering theory, particle in spherical box); Free particle wavefunctions." }, 'spherbessely': { plot: true, func: spherBesselY, name: "Spherical Bessel (2nd Kind)", param1: 'l', param2: null, eq: `y_l(x) = \\sqrt{\\frac{\\pi}{2x}} Y_{l+1/2}(x)`, xRange: [0.1, 20], yRange: [-1.5, 0.5], p1Max: 5, physicsUses: "Radial solutions in spherical coordinates (origin excluded); Scattering theory." }, 'gamma': { plot: true, func: gammaFunc, name: "Gamma Function", param1: null, param2: null, eq: `\\Gamma(x) = \\int_0^\\infty t^{x-1}e^{-t} dt`, xRange: [-4, 5], yRange: [-10, 10], physicsUses: "Statistical mechanics (partition functions, phase space); String theory; Normalization constants; Regularization in QFT." }, 'beta': { plot: true, func: betaFunc, name: "Beta Function", param1: 'n', param2: null, eq: `B(x, n) = \\int_0^1 t^{x-1}(1-t)^{n-1} dt = \\frac{\\Gamma(x)\\Gamma(n)}{\\Gamma(x+n)}`, xRange: [0.1, 5], yRange: [0, 5], p1Max: 5, physicsUses: "Scattering amplitudes (Veneziano amplitude in string theory); Probability theory (Beta distribution); Evaluating Feynman integrals." }, 'digamma': { plot: false, func: null, name: "Digamma Function", param1: null, param2: null, eq: `\\psi(x) = \\frac{d}{dx} \\ln \\Gamma(x) = \\frac{\\Gamma'(x)}{\\Gamma(x)}`, xRange: [-4, 4], yRange: [-5, 5], physicsUses: "Quantum field theory (renormalization, loop calculations); Statistical mechanics; Summation of series." }, 'hypergeom': { plot: false, func: null, name: "Hypergeometric Function", param1: null, param2: null, eq: `_2F_1(a, b; c; z) = \\sum_{k=0}^{\\infty} \\frac{(a)_k (b)_k}{(c)_k} \\frac{z^k}{k!}`, physicsUses: "Exact solutions to Schrödinger eq. for specific potentials; General relativity solutions; Conformal field theory." }, 'confhypergeom': { plot: false, func: null, name: "Confluent Hypergeometric", param1: null, param2: null, eq: `_1F_1(a; b; z) = M(a, b, z) = \\sum_{k=0}^{\\infty} \\frac{(a)_k}{(b)_k} \\frac{z^k}{k!}`, physicsUses: "Hydrogen atom radial solutions; Quantum Coulomb scattering; Plasma physics." }, 'ellipticint': { plot: false, func: null, name: "Elliptic Integrals", param1: null, param2: null, eq: `K(k) = \\int_0^{\\pi/2} \\frac{d\\theta}{\\sqrt{1-k^2 \\sin^2\\theta}}, \\quad E(k) = \\int_0^{\\pi/2} \\sqrt{1-k^2 \\sin^2\\theta} d\\theta`, physicsUses: "Exact pendulum period; Geodesics in curved spacetime (General Relativity); Nonlinear oscillators; Magnetic fields." }, 'ellipticfunc': { plot: false, func: null, name: "Jacobi Elliptic Functions", param1: null, param2: null, eq: `\\mathrm{sn}(u, k), \\mathrm{cn}(u, k), \\mathrm{dn}(u, k)`, physicsUses: "Nonlinear wave equations (KdV solutions); Rigid body rotation (classical mechanics); Nonlinear oscillators." }, 'airy': { plot: false, func: null, name: "Airy Functions", param1: null, param2: null, eq: `\\mathrm{Ai}(x) = \\frac{1}{\\pi} \\int_0^\\infty \\cos(\\frac{t^3}{3} + xt) dt, \\quad \\mathrm{Bi}(x)`, physicsUses: "Quantum mechanics (linear potential, tunneling); Optics (caustics, rainbows); WKB approximation near turning points." }, 'erf': { plot: true, func: erfFunc, name: "Error Function", param1: null, param2: null, eq: `\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt`, xRange: [-3, 3], yRange: [-1.1, 1.1], physicsUses: "Diffusion equation solutions; Heat conduction; Probability & statistics (normal distribution); Brownian motion." }, 'heaviside': { plot: true, func: heaviside, name: "Heaviside Step Function", param1: null, param2: null, eq: `H(x) = \\begin{cases} 0 & x < 0 \\\\ 1 & x \\ge 0 \\end{cases}`, xRange: [-2, 2], yRange: [-0.2, 1.2], physicsUses: "Signal processing (step inputs); Circuit theory (switching); Control systems; Causal Green's functions." }, 'dirac': { plot: true, func: diracDelta, name: "Dirac Delta", param1: null, param2: null, eq: `\\delta(x) = \\begin{cases} +\\infty & x = 0 \\\\ 0 & x \\neq 0 \\end{cases}, \\quad \\int_{-\\infty}^{\\infty} \\delta(x) dx = 1`, xRange: [-2, 2], yRange: [0, 1], physicsUses: "Representing point charges/masses/impulses; Green's functions; Quantum mechanics (eigenstates); Impulse response." } };

    // --- DOM Element References ---
    // Defined globally within script scope now
    const plotDiv = document.getElementById('plot');
    const plotMessageDiv = document.getElementById('plotMessage');
    const functionSelect = document.getElementById('functionSelect');
    const paramSlider = document.getElementById('paramSlider');
    const paramValueSpan = document.getElementById('paramValue');
    const paramLabel = document.getElementById('paramLabel');
    const paramSlider2 = document.getElementById('paramSlider2');
    const paramValueSpan2 = document.getElementById('paramValue2');
    const paramLabel2 = document.getElementById('paramLabel2');
    const infoContainer = document.getElementById('infoContainer');
    const equationDisplay = document.getElementById('equationDisplay');
    const physicsUsesDisplay = document.getElementById('physicsUsesDisplay');

    // --- Update Plot Function ---
    // Modified to use MathJax instead of KaTeX
    function updatePlot() {
        if (!functionSelect || !equationDisplay || !physicsUsesDisplay || !plotDiv || !plotMessageDiv) { console.error("UpdatePlot error: DOM elements not found."); return; }
        const selectedValue = functionSelect.value; const config = functionMap[selectedValue] || functionMap['legendre'];
        let param1Value = 0, param2Value = 0;
        paramSlider.style.display = 'none'; paramValueSpan.style.display = 'none'; paramLabel.style.display = 'none';
        paramSlider2.style.display = 'none'; paramValueSpan2.style.display = 'none'; paramLabel2.style.display = 'none';
        if (config.param1) { paramSlider.style.display = 'inline-block'; paramValueSpan.style.display = 'inline'; paramLabel.style.display = 'inline'; paramLabel.textContent = `${config.param1}:`; paramSlider.max = config.p1Max || 5; paramSlider.value = Math.min(paramSlider.value, paramSlider.max); paramSlider.value = Math.max(paramSlider.value, paramSlider.min || 0); param1Value = parseInt(paramSlider.value); paramValueSpan.textContent = `${config.param1} = ${param1Value}`; paramSlider.disabled = false; } else { paramSlider.disabled = true; }
        if (config.param2) { paramSlider2.style.display = 'inline-block'; paramValueSpan2.style.display = 'inline'; paramLabel2.style.display = 'inline'; paramLabel2.textContent = `${config.param2}:`; const p2Max = typeof config.p2MaxFunc === 'function' ? config.p2MaxFunc(param1Value) : (config.p2Max || param1Value); const p2Min = config.p2Min === undefined ? 0 : config.p2Min; paramSlider2.max = p2Max; paramSlider2.min = p2Min; if (selectedValue === 'assoclegendre' || selectedValue === 'spherharm') { paramSlider2.min = -param1Value; paramSlider2.max = param1Value; } paramSlider2.value = Math.min(paramSlider2.value, paramSlider2.max); paramSlider2.value = Math.max(paramSlider2.value, paramSlider2.min); param2Value = parseInt(paramSlider2.value); paramValueSpan2.textContent = `${config.param2} = ${param2Value}`; paramSlider2.disabled = false; } else { paramSlider2.disabled = true; }

        // --- MathJax Rendering ---
        let finalEq = config.eq;
        if(config.param1) {
            finalEq = finalEq.replace(`_${config.param1}`, `_{${param1Value}}`);
            finalEq = finalEq.replace(`(${config.param1}`, `(${param1Value}`);
            if(config.param2) {
                finalEq = finalEq.replace(`^${config.param2}`, `^{${param2Value}}`);
                finalEq = finalEq.replace(`(${config.param2})`, `(${param2Value})`);
                if (config.param2 === 'm') {
                    finalEq = finalEq.replace(/m!/g, `${param2Value}!`);
                    finalEq = finalEq.replace(/im\\phi/g, `${param2Value}i\\phi`);
                }
                finalEq = finalEq.replace(`P_${config.param1}^${config.param2}`, `P_{${param1Value}}^{${param2Value}}`);
            }
        }
        // Set the innerHTML with MathJax delimiters
        equationDisplay.innerHTML = `<strong>${config.name}:</strong> \\( ${finalEq} \\)`;

        // Tell MathJax to typeset the updated element
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            MathJax.typesetPromise([equationDisplay]).catch((err) => console.error('MathJax typesetting error:', err));
        } else {
             console.error("MathJax library not loaded or typesetPromise not available.");
             equationDisplay.innerHTML += ` (MathJax not loaded - cannot render equation)`;
        }
        // --- End MathJax Rendering ---

        if(config.physicsUses) { physicsUsesDisplay.innerHTML = `<strong>Use in Physics:</strong> ${config.physicsUses.replace(/;/g, ';<br>')}`; } else { physicsUsesDisplay.innerHTML = `<strong>Use in Physics:</strong> N/A`; }
        if (typeof Plotly === 'undefined') { console.error("Plotly library not loaded."); plotMessageDiv.textContent = "Error: Plotting library failed to load."; plotMessageDiv.style.display = 'block'; if (plotDiv) Plotly.purge(plotDiv); return; }
        if (!config.plot) { Plotly.purge(plotDiv); plotMessageDiv.textContent = "Plotting for this function is not implemented in this example."; plotMessageDiv.style.display = 'block'; return; } else { plotMessageDiv.style.display = 'none'; }
        const currentFunc = config.func; if (typeof currentFunc !== 'function') { console.error(`Plotting function for ${selectedValue} is not defined.`); plotMessageDiv.textContent = `Error: Plotting function for ${selectedValue} is missing.`; plotMessageDiv.style.display = 'block'; Plotly.purge(plotDiv); return; }
        const [xMin, xMax] = config.xRange; const numPoints = 400; const xValues = []; const yValues = [];
        for (let i = 0; i <= numPoints; i++) { let x = xMin + (xMax - xMin) * i / numPoints; if ((selectedValue === 'gamma' || selectedValue === 'beta' || selectedValue === 'bessely' || selectedValue === 'besselk' || selectedValue === 'spherbessely') && x <= 0) { x = 1e-6; } if (selectedValue === 'gamma' && Math.abs(x - Math.round(x)) < 1e-9 && x <= 0) { x += 1e-6; } if ((selectedValue === 'spherbesselj' || selectedValue === 'spherbessely') && Math.abs(x) < 1e-15) { x = 1e-6; } xValues.push(x); const y = config.param2 ? currentFunc(param1Value, param2Value, x) : currentFunc(param1Value, x); yValues.push(y); }
        const trace = { x: xValues, y: yValues.map(y => (isFinite(y) ? y : null)), mode: 'lines', name: config.name + (config.param1 ? ` (${config.param1}=${param1Value}${config.param2 ? `, ${config.param2}=${param2Value}` : ''})` : ''), line: { shape: selectedValue === 'heaviside' ? 'hv' : 'spline' } };
        const layout = { title: config.name + (config.param1 ? ` for ${config.param1}=${param1Value}${config.param2 ? `, ${config.param2}=${param2Value}` : ''}` : ''), xaxis: { title: 'x', range: config.xRange, zeroline: true }, yaxis: { title: 'Value', range: config.yRange, zeroline: true, autorange: !config.yRange }, margin: { t: 50, b: 50, l: 60, r: 30 }, hovermode: 'closest', annotations: [] };
        if (selectedValue === 'dirac') { layout.yaxis.range = [0, 1.2]; layout.annotations.push({ x: 0, y: 1, ax: 0, ay: 0, xref: 'x', yref: 'y', axref: 'x', ayref: 'y', showarrow: true, arrowhead: 2, arrowsize: 1.5, arrowwidth: 2, arrowcolor: 'rgb(255, 0, 0)' }); trace.x = []; trace.y = []; }
        try { Plotly.react(plotDiv, [trace], layout); } catch(e) { console.error("Plotly error:", e); plotMessageDiv.textContent = "An error occurred while plotting."; plotMessageDiv.style.display = 'block'; }
    }

    // --- Initialization code (runs after HTML parsing because script has no defer/async) ---
    // Ensure DOM is fully ready before interacting with it, although synchronous script execution after body usually guarantees this.
    // Using DOMContentLoaded might be slightly safer but adds complexity.
    if (document.readyState === 'loading') { // Optional check
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize(); // DOM already ready
    }

    function initialize() {
        console.log("Initializing plotter script...");
        // Check if essential elements exist before adding listeners
        if (!functionSelect || !paramSlider || !paramSlider2 || !plotDiv) {
             console.error("Critical Error: Could not find essential DOM elements during initialization. Aborting.");
             document.body.innerHTML = '<h1 style="color:red;">Error: Page elements failed to load correctly.</h1>';
             return; // Stop initialization
        }
        console.log("DOM elements found. Adding event listeners...");
        // Add Event Listeners
        functionSelect.addEventListener('change', () => {
            const config = functionMap[functionSelect.value];
            // Ensure sliders exist before trying to set value (should always be true here)
            if (paramSlider) paramSlider.value = config.param1 ? Math.min(2, config.p1Max || 5) : 0;
            if (paramSlider2) paramSlider2.value = 0;
            updatePlot(); // Update plot on function change
        });
        paramSlider.addEventListener('input', updatePlot);
        paramSlider2.addEventListener('input', updatePlot);

        console.log("Event listeners added. Performing initial plot...");
        // Initial Plot
        updatePlot();
        console.log("Initialization complete.");
    }

</script>

</body>
</html>